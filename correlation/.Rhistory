FeaturePlot(seu, features = "RBFOX3")
FeaturePlot(seu, features = "TUBB3")
FeaturePlot(seu, features = "SYT1")
FeaturePlot(seu, features = "DLG4") # PSD95
?FeaturePlot
FeaturePlot(seu, features = neurons, ncol = 3, slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='99',label.size = 1)+ theme(plot.title = element_text(size = 0.1))
# NeuN RBFOX3
# PSD95 is DLG4
neurons <- c("TUBB3","RBFOX3","SYT1","DLG4", "CD200","TH","ALDH1A1","IFNAR1","IFNAR2","MAP2","GRIN2A","GRIA2")
DoHeatmap(seu,features = neurons, group.by = "RNA_snn_res.0.5")
FeaturePlot(seu, features = neurons, ncol = 3, slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='99',label.size = 1)+ theme(plot.title = element_text(size = 0.1))
FeaturePlot(seu, features = neurons, ncol = 3, slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='98',label.size = 1)+ theme(plot.title = element_text(size = 0.1))
DoHeatmap(seu,features = neurons, group.by = "RNA_snn_res.0.5")
# NeuN RBFOX3
# PSD95 is DLG4
neurons <- c("TUBB3","RBFOX3","SYT1","DLG4", "CD200","TH","ALDH1A1","IFNAR1","IFNAR2","MAP2","GRIN2A","GRIA2")
png(paste(output,"HeatmapRes05neuron.png"), height = 500, width = 600)
DoHeatmap(seu,features = neurons, group.by = "RNA_snn_res.0.5")
dev.off()
png(paste(output,"FeatureNeuronMarkers.png"), height = 2500, width = 2000)
FeaturePlot(seu, features = neurons, ncol = 3, slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='98',label.size = 1)+ theme(plot.title = element_text(size = 0.1))
dev.off()
png(paste(output,"UMAPclustersRes05.png"), height = 800, width = 1000)
DimPlot(seu, reduction = "umap", group.by = "RNA_snn_res.0.5")
dev.off()
png(paste(output,"FeatureNeuronMarkers.png"), height = 2000, width = 2500)
FeaturePlot(seu, features = neurons, ncol = 3, slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='98',label.size = 1)+ theme(plot.title = element_text(size = 0.1))
dev.off()
# all groups of cells
png(paste(output,"HeatmapbyCellLine.png"), height = 500, width = 600)
DoHeatmap(seu,features = neurons, group.by = "Lables")
dev.off()
png(paste(output,"DotPlotbyCellLine.png"), height = 500, width = 600)
DoPlot(seu,features = neurons, group.by = "Lables")
png(paste(output,"DotPlotbyCellLine.png"), height = 500, width = 600)
DotPlot(seu,features = neurons, group.by = "Lables")
dev.off()
png(paste(output,"UMAPcellLines.png"), height = 800, width = 1000)
DimPlot(seu, reduction = "umap", group.by = "Lables")
dev.off()
DoHeatmap(seu,features = neurons, group.by = "Lables")
DotPlot(seu,features = neurons, group.by = "Lables")
png(paste(output,"DotPlotDH1A1.allcells.png"), height = 600, width = 800)
DotPlot(seu, features = c("ALDH1A1","IFNAR1","IFNAR2","TH"), group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
png(paste(output,"DotPlotbyCellLine.png"), height = 500, width = 600)
DotPlot(seu,features = neurons, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
DotPlot(seu,features = neurons, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
GOI <- c("PRNK","PINK1","GBA1","SNCA")
png(paste(output,"DotPlotbyCellLineGOI.png"), height = 500, width = 600)
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
GOI <- c("PRKN","PINK1","GBA","SNCA")
png(paste(output,"DotPlotbyCellLineGOI.png"), height = 500, width = 600)
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
png(paste(output,"HeatmapbyCellLineGOI.png"), height = 500, width = 600)
DoHeatmap(seu,features = GOI, group.by = "Lables")
dev.off()
DoHeatmap(seu,features = GOI, group.by = "Lables")
GOI <- c("PRKN","PINK1","GBA","SNCA","LRRK2")
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
GOI <- c("SOX1","SOX2","NES","PROM1")
png(paste(output,"DotPlotbyCellLineNeuralStemMarkers.png"), height = 500, width = 600)
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
png(paste(output,"DotPlotbyClusterNeuralStemMarkers.png"), height = 500, width = 600)
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
png(paste(output,"DotPlotbyClusterNeuralStemMarkers.png"), height = 500, width = 600)
DotPlot(seu,features = GOI, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = GOI, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
astro <- c("CD44","GFAP","AQP4","S100B","ALDH1L1","VIM")
png(paste(output,"DotPlotbyCellLineGliaMarkers.png"), height = 500, width = 600)
DotPlot(seu,features = astro, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
png(paste(output,"DotPlotbyClusterGliaMarkers.png"), height = 500, width = 600)
DotPlot(seu,features = astro, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
dev.off()
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = GOI, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = astro, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = GOI, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = GOI, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = astro, group.by = "Lables")+ theme(axis.text.x = element_text(angle = 90))
DotPlot(seu,features = astro, group.by = "RNA_snn_res.0.5")+ theme(axis.text.x = element_text(angle = 90))
stats_list <- readRDS(paste(output_path,input_name,clust_method,'statslist.Rds',sep=""))
output_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/Figure3/cluster_parameters/Pheno/"
input_name <- "FlowAlignTrans"  # this will be the different processing types
# cluster type for file name
clust_method <- "Pheno"
stats_list <- readRDS(paste(output_path,input_name,clust_method,'statslist.Rds',sep=""))
pdf(paste(output_path,input_name,clust_method,'statssilhouette.pdf',sep=""),width =4, height = 4)
print(plot(kn, type='b', stats_list[[2]][kn], xlab='k-neigbours', ylab='Average Silhouette Scores', frame=TRUE))
kn = c(25,50,75,100,125,150,175,200,225,250,300,350,400,450,500)
pdf(paste(output_path,input_name,clust_method,'statssilhouette.pdf',sep=""),width =4, height = 4)
print(plot(kn, type='b', stats_list[[2]][kn], xlab='k-neigbours', ylab='Average Silhouette Scores', frame=TRUE))
dev.off()
#Calinski-Harabasz index:
# the highest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,'statsCalinskiHara.pdf',sep=""),width =4, height = 4)
print(plot(kn, type='b', stats_list[[3]][kn], xlab='k-neigbours', ylab='Calinski-Harabasz index', frame=TRUE))
dev.off()
#Davies–Bouldin index: minimum score is zero
#the lowest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,'statsDavies.pdf',sep=""),width =4, height = 4)
print(plot(kn, type='b', stats_list[[4]][kn], xlab='k-neigbours', ylab='Davies–Bouldin index', frame=TRUE))
dev.off()
plot(kn, type='b', stats_list[[2]][kn], xlab='k-neigbours', ylab='Average Silhouette Scores', frame=TRUE)
View(stats_list)
plot(kn, type='b', stats_list[[3]][kn], xlab='k-neigbours', ylab='Calinski-Harabasz index', frame=TRUE)
# flowsom clustering
# parameter tuning, statistic and visualizations for manual annotation
# load libraries
library(clusterSim) #new package for dbi
library(FlowSOM)
library(flowCore)
library(cluster)
library(fpc)
library(Seurat)
library(dplyr)
library(ggplot2)
library(clustree)
############# set up the data object for clustering ############################
# define the input pathway
input_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/prepro_outsretrotransformed_flowset.csv"
# output pathway
output_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/Figure3/cluster_parameters/Flowsom-retro/"
# add input description to output files
input_name <- "AlignRetroTrans"  # this will be the different processing types
# cluster type for file name
clust_method <- "FlowSOM"
# read in the dataframe
df <- read.csv(input_path)
# print info to log
print(dim(df)) # this is specific df has 73578 cells
# the preprocessing output csv needs to be cleaned - it contains live dead, FSC, SSC and the sample column
print(colnames(df))
# create a df with just the expression
# need a way to automate this selection
# I only want the expression values
df2 <- df %>% select(c("AQP4", "CD24", "CD44","CD184","CD15","HepaCAM","CD29","CD56", "O4","CD140a","CD133","GLAST","CD71"))
# the order of the DF is set by the order the colunms are written above
# create a matrix for later
print(colnames(df2))
m <- as.matrix(df2)
# create the flowframe
# if reading in a csv convert to flowset
frame <- new("flowFrame", exprs = m) #convert input to flowframe
fs <- ReadInput(frame) #convert flowframe to flowsom object
fs <- BuildSOM(fs) # build flowSOM object, no need for -1 because I cleaned the df about before making flowset
fs <- BuildMST(fs) # build minimum spanning tree
# BuildMST(flowSOM object generated by buildSOM)
# create the seurat object for visualization
tm <- t(df2)
rownames(tm) <- colnames(df2)
colnames(tm) <- rownames(df2)
seu <- CreateSeuratObject(tm) # create a seurat object
# add the meta data back in for sample groups
seu <- AddMetaData(object=seu, metadata=df$Batch, col.name = 'Batch')
# this doesn't work for making levels
# create the vector for the antibodies names for feature plotting later
AB <- colnames(df2)
# add to scale data slot
seu <- ScaleData(seu)
# check the data
pdf(paste(output_path,input_name,clust_method,"Heatmap_batch.pdf",sep=""),width =8, height = 6)
print(DoHeatmap(seu, group.by = "Batch", features = AB))
dev.off()
# create the UMAP
seu <- RunPCA(seu, features = AB, npcs = 12, approx = FALSE)
# I've tried scaling the kn with the k but the values to no result in UMAP that spatial match cluster
# I'll just run the UMAP once with the kn = square root of the number of inputs
kn = round(sqrt(dim(df2)[1]))
seu <- FindNeighbors(seu, dims = 1:12, k = kn)
seu <- RunUMAP(seu, dims = 1:12, n.neighbors = kn)
# save feature plots of this UMAP
# just for testing print
# we also only need to plot the features once
# file name
UMAP_name = paste("UMAPfeatures_kn",kn,".pdf",sep="")
print(UMAP_name) #testing
# save feature plots UMAP
pdf(paste(output_path,input_name,clust_method,UMAP_name,sep=""),width =20, height = 10)
print(FeaturePlot(seu, features = AB,slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='99',label.size = 1)+ theme(plot.title = element_text(size = 0.1)))
dev.off()
############################## explore parameters and calculate statistics ###########################
# here k is the number of clusters
#shuming: somehow 2 doesn't work with flowsom, im not suring why
#krange = 3:30
#krange = seq(from = 5, to = 100, by = 5)
# this cause a problem - it doesn't include the last 2 values in the loop
krange = c( 5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90)
# the k will be the max k for the metaclustering clustering.
# save a data object for each kn - will only keep temporarily
# the clusters will write over with each new kn
#stats lists
si <- list()
ch <- list()
db <- list()
numb.clust <- list()
#subsample for silhouette score
#shuming: here im using 1000 so it's not too slow, but 30,000 would be have better representation
row_n <- sample(1:nrow(m), 1000)
dis <- dist(m[row_n,])
for (i in krange){
# K max number of clusters not the kn input
## run flowSOM clustering
## easy flowsom method : scales data nClus is the k we are forcing
fs <- FlowSOM(
frame,
nClus = i,
seed = 42
)
# get the clusters from FlowSom
flowSOMcluster <- GetMetaclusters(fs, meta=metaClustering_consensus(fs$map$codes,k = i,seed=42))
# name the clustering
clust_name = paste('FlowSom.k.',i,sep="")
# add the cluster ID into seurat object to visualize
seu <- AddMetaData(object=seu, metadata= flowSOMcluster[fs$map$mapping[,1]], col.name = clust_name)
number.clusters <- length(unique(flowSOMcluster[fs$map$mapping[,1]]))
### make umap
#UMAP_name = paste("UMAPclusters_k",i,".pdf",sep="")
#print(UMAP_name) #testing
#pdf(paste(output_path,input_name,clust_method,UMAP_name,sep=""),width =8, height = 5)
# save UMAP grouped
#print(DimPlot(seu,reduction = "umap", repel = TRUE, label = TRUE, group.by = clust_name)) # will automatically group by active ident
#dev.off()
# the pdf don't work well for a quick figure
UMAP_name = paste("UMAPclusters_k",i,".png",sep="")
print(UMAP_name) #testing
png(paste(output_path,input_name,clust_method,UMAP_name,sep=""))
# save UMAP grouped
print(DimPlot(seu,reduction = "umap", repel = TRUE, label = TRUE, group.by = clust_name)) # will automatically group by active ident
dev.off()
# heatmap
#heatmap_name = paste("Heatmapclusters_k",i,".pdf",sep="")
#testing
#pdf(paste(output_path,input_name,clust_method,heatmap_name,sep=""),width =8, height = 5)
#print(DoHeatmap(seu, features = AB,group.by = clust_name))
#dev.off()
# heatmap
heatmap_name = paste("Heatmapclusters_k",i,".png",sep="")
#testing
png(paste(output_path,input_name,clust_method,heatmap_name,sep=""), width = 600, height = 500)
print(DoHeatmap(seu, features = AB,group.by = clust_name, size = 10) +theme(text = element_text(size = 30)))
dev.off()
#### add stats
# calculate the statistics
#number of clusters
numb.clust[i] <- number.clusters # calculated above
#silhouette score:
si[i] <- mean(silhouette(flowSOMcluster[row_n],dis)[, 3])
#Calinski-Harabasz index:
ch[i] <- calinhara(m,flowSOMcluster,cn=i)
# Davies–Bouldin index:
db[i] <- index.DB(df2, as.numeric(flowSOMcluster))$DB
# send stats to stats_list (or df or whatever works)
# make plots
# UMAP
# save stats for each resolution
# write.csv(stats_list, paste(output_path,list_name,sep=""))
}
#stats list
stats_list <- list(numb.clust, si, ch, db)
# write.csv(stats_list, )
#make stats plots
# shuming: commenting out because I'm not sure where you want the graphs to be saved in
# pdf(),width =, height = )
#silhouette score:
#-1: bad clusters  0: neutral, indifferent  1: good clusters
pdf(paste(output_path,input_name,clust_method,'statssilhouette.pdf',sep=""),width =4, height = 4)
print(plot(krange, type='b', stats_list[[1]][krange], xlab='k max', ylab='Average Silhouette Scores', frame=TRUE))
dev.off()
#Calinski-Harabasz index:
# the highest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,'statsCalinskiHara.pdf',sep=""),width =4, height = 4)
print(plot(krange, type='b', stats_list[[2]][krange], xlab='k max', ylab='Calinski-Harabasz index', frame=TRUE))
dev.off()
#Davies–Bouldin index: minimum score is zero
#the lowest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,'statsDavies.pdf',sep=""),width =4, height = 4)
print(plot(krange, type='b', stats_list[[3]][krange], xlab='k max', ylab='Davies–Bouldin index', frame=TRUE))
dev.off()
# make clustree plot
pdf(paste(output_path,input_name,clust_method,'Clustree.pdf',sep=""),width =8, height = 8)
print(clustree(seu, prefix ='FlowSom.k.'))
dev.off()
# save the UMAP with cell types
pdf(paste(output_path,input_name,clust_method,'UMAPcelltype.pdf',sep=""),width =8, height = 6)
print(DimPlot(seu,group.by = 'Batch'))
dev.off()
# save the Seurat object
saveRDS(seu,paste(output_path,input_name,clust_method,'SeuratObject.Rds',sep=""))
# save the stats list
saveRDS(stats_list,paste(output_path,input_name,clust_method,'statslist.Rds',sep=""))
View(numb.clust)
View(stats_list)
#-1: bad clusters  0: neutral, indifferent  1: good clusters
pdf(paste(output_path,input_name,clust_method,'statssilhouette.pdf',sep=""),width =4, height = 4)
print(plot(krange, type='b', stats_list[[2]][krange], xlab='k max', ylab='Average Silhouette Scores', frame=TRUE))
dev.off()
#Calinski-Harabasz index:
# the highest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,'statsCalinskiHara.pdf',sep=""),width =4, height = 4)
print(plot(krange, type='b', stats_list[[3]][krange], xlab='k max', ylab='Calinski-Harabasz index', frame=TRUE))
dev.off()
#Davies–Bouldin index: minimum score is zero
#the lowest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,'statsDavies.pdf',sep=""),width =4, height = 4)
print(plot(krange, type='b', stats_list[[4]][krange], xlab='k max', ylab='Davies–Bouldin index', frame=TRUE))
dev.off()
# flowsom clustering
# parameter tuning, statistic and visualizations for manual annotation
# @Shuming: make this whole script into a function.
# input option:  input_path, output_path, input_name, cluster_method, kn, resolutions
# input_name and cluster_method are for file names to keep track of the output
# kn and resolution needs to take a vector
# an option to turn off or on save plots would be helpful too.
# add plot with x axis as the number of clusters, kn by colour intensity, res by shape or different colour
# values as dots, y axis statistic
# need to get the number of clusters at each kn/res combination
# load libraries
library(clusterSim)
library(FlowSOM)
library(flowCore)
library(cluster)
library(fpc)
library(clv)
library(Seurat)
library(dplyr)
library(ggplot2)
library(clustree)
library(reshape2) #for plotting multiple lines (resolutions) on the same graph
############# set up the data object for clustering ############################
# info to change for each comparison
# define the input pathway
# input pathway
# input pathway
input_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/prepro_outsaligned_transformed_flowset.csv"
# output pathway
output_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/Figure3/cluster_parameters/Louvain/"
# add input description to output files
input_name <- "Flowset"  # this will be the different processing types
# cluster type for file name
clust_method <- "Louvain"
# read in the dataframe
df <- read.csv(input_path)
# print info to log
print(dim(df)) # this is specific df has 73578 cells
# the preprocessing output csv needs to be cleaned - it contains live dead, FSC, SSC and the sample column
print(colnames(df))
# create a df with just the expression
# need a way to automate this selection
# I only want the expression values
df2 <- df %>% select(c("AQP4", "CD24", "CD44","CD184","CD15","HepaCAM","CD29","CD56", "O4","CD140a","CD133","GLAST","CD71"))
# the order of the DF is set by the order the columns are written above
# create a matrix for later
m <- as.matrix(df2)
# create the seurat object for visualization
tm <- t(df2)
rownames(tm) <- colnames(df2)
colnames(tm) <- rownames(df2)
seu <- CreateSeuratObject(tm) # create a seurat object
# add the meta data back in for sample groups
seu <- AddMetaData(object=seu, metadata=df$Batch, col.name = 'Batch')
# this doesn't work for making levels
# create the vector for the antibodies names for feature plotting later
AB <- colnames(df2)
# add to scale data slot
seu <- ScaleData(seu)
# check the data
pdf(paste(output_path,input_name,clust_method,"Heatmap_batch.pdf",sep=""),width =8, height = 6)
print(DoHeatmap(seu, group.by = "Batch", features = AB))
dev.off()
# create the UMAP
seu <- RunPCA(seu, features = AB, npcs = 12, approx = FALSE)
############################## explore parameters and calculate statistics ###########################
############################# define pararmater range and set up list for stats ########################################
#shuming: im getting NaN for all clusters with res = 0.01
#those clusters seem to have level 0?
kn = c(25,50,100,125,150,200,250,300)
resolutions = c(0.05,0.1,0.2,0.3,0.4,0.5,0.6,0.7,1.0,1.8)
# not in the aligned transformed the number of clusters is very high at low k and higher
# more clusters are being formed in all methods
#create 3 df for stats, can be simplified later
si <- data.frame(matrix(ncol = length(resolutions), nrow = length(kn)))
colnames(si) <- resolutions
rownames(si) <- kn
ch <- data.frame(matrix(ncol = length(resolutions), nrow = length(kn)))
colnames(ch) <- resolutions
rownames(ch) <- kn
db <- data.frame(matrix(ncol = length(resolutions), nrow = length(kn)))
colnames(db) <- resolutions
rownames(db) <- kn
# track number of clusters
nc <- data.frame(matrix(ncol = length(resolutions), nrow = length(kn)))
colnames(db) <- resolutions
rownames(db) <- kn
#subsampling for silhouette score, n=1000, can make n bigger if needed
row_n <- sample(1:nrow(m), 1000)
dis <- dist(m[row_n,])
# In the loop
# save a data object for each kn - will only keep temporarily
# the clusters will write over with each new kn
for (i in kn){
seu <- FindNeighbors(seu, dims = 1:12, k.param = i)
seu <- RunUMAP(seu, dims = 1:12, n.neighbors = i)
# save feature plots of this UMAP
# file name
UMAP_name = paste("UMAPfeatures_kn",i,".pdf",sep="")
# save feature plots UMAP
pdf(paste(output_path,input_name,clust_method,UMAP_name,sep=""),width =20, height = 10)
print(FeaturePlot(seu, features = AB,slot = 'scale.data',min.cutoff = 'q1', max.cutoff ='99',label.size = 1)+ theme(plot.title = element_text(size = 0.1)))
dev.off()
# look at batches
UMAP_name = paste("UMAPbatches_kn",i,".pdf",sep="")
pdf(paste(output_path,input_name,clust_method,UMAP_name,sep=""),width =20, height = 10)
print(DimPlot(seu,group.by = 'Batch',label.size = 1))
dev.off()
for (j in resolutions) {
seu <- FindClusters(seu, resolution = j)
louvainCluster <- seu@meta.data$seurat_clusters
numb.clusters = unique(seu@meta.data$seurat_clusters)
#shuming: get an error whenever i run stats on level 0 clusters (mentioned in
#line 94) this line skips the rest of the loop when that happens, you might
#want to move stats to the end of the inner loop so you don't skip the plots
# this should add the number of clusters into a list - it didn't seem to work, something like this should work
nc[as.character(i), as.character(j)] <- length(unique(louvainCluster))
if (length(unique(louvainCluster))==1) next
#silhouette score:
si[as.character(i), as.character(j)] <- mean(silhouette(as.numeric(louvainCluster[row_n]),dis)[, 3])
length(as.numeric(dis))
silhouette(as.numeric(louvainCluster[row_n]),dis)
# @shuming - what is the point of the next line
as.numeric(louvainCluster[row_n])
#Calinski-Harabasz index:
ch[as.character(i), as.character(j)] <- calinhara(m,louvainCluster,cn=i)
# Davies–Bouldin index:
db[as.character(i), as.character(j)] <- index.DB(df2, as.numeric(louvainCluster))$DB
# make plots
# UMAP
UMAP_name = paste("UMAPclusters_kn",i,"_res_",j,".pdf",sep="")
print(UMAP_name) #testing
pdf(paste(output_path,input_name,clust_method,UMAP_name,sep=""),width =8, height = 5)
# save UMAP grouped
print(DimPlot(seu,reduction = "umap", repel = TRUE, label = TRUE)) # will automatically group by active ident
dev.off()
# heatmap
heatmap_name = paste("Heatmapclusters_kn",i,"_res_",j,".pdf",sep="")
#testing
pdf(paste(output_path,input_name,clust_method,heatmap_name,sep=""),width =8, height = 5)
print(DoHeatmap(seu, features = AB))
dev.off()
# save stats for each resolution
# write.csv(stats_list, paste(output_path,list_name,sep=""))
}
# run clustree
pdf(paste(output_path,input_name,clust_method,"kn",i,'Clustree.pdf',sep=""),width =15, height = 10)
print(clustree(seu, prefix ='RNA_snn_res.'))
dev.off()
# save seurat object
seu_name = paste("SeuratObject",i,".Rds",sep="")
saveRDS(seu, paste(output_path,input_name,clust_method,seu_name,sep=""))
# make clustree plot
# save all stats outputs for each kn
}
# save the stats
stats_list <- list(si,ch,db,nc)
saveRDS(stats_list,paste(output_path,input_name,clust_method,'statslist.Rds',sep=""))
############################## Plot outputs ########################################
#Shuming: this could also be simplified later by making a general plotting function
#silhouette score: ranges from -1  to 1
#-1: bad clusters  0: neutral, indifferent  1: good clusters
pdf(paste(output_path,input_name,clust_method,"Silhouetteplot.pdf",sep=""), width = 4, height = 4)
si_new <- cbind(kn = rownames(si), si)
melted <- melt(si_new,  id.vars = 'kn', variable.name = 'resolutions')
ggplot(melted, aes(kn, value)) +
geom_line(aes(colour = resolutions, group = resolutions)) +
labs(title = "Silhouette Scores", x = "kn", y = "Average Silhouette Scores") +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
write.csv(si_new,paste(output_path,input_name,clust_method,"SilhouetteStats.csv",sep=""))
# #Calinski-Harabasz index:
# # the highest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,"CHIplot.pdf",sep=""), width = 4, height = 4)
ch_new <- cbind(kn = rownames(ch), ch)
melted <- melt(ch_new,  id.vars = 'kn', variable.name = 'resolutions')
ggplot(melted, aes(kn, value)) +
geom_line(aes(colour = resolutions, group = resolutions)) +
labs(title = "Calinski-Harabasz Index", x = "kn", y = "Calinski-Harabasz Index") +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
write.csv(ch_new,paste(output_path,input_name,clust_method,"CHIStats.csv",sep=""))
# #Davies–Bouldin index: minimum score is zero
# #the lowest value is the optimal number of clusters
pdf(paste(output_path,input_name,clust_method,"DBplot.pdf",sep=""), width = 4, height = 4)
db_new <- cbind(kn = rownames(db), db)
melted <- melt(db_new,  id.vars = 'kn', variable.name = 'resolutions')
ggplot(melted, aes(kn, value)) +
geom_line(aes(colour = resolutions, group = resolutions)) +
labs(title = "Davies–Bouldin Index", x = "kn", y = "Davies–Bouldin Index") +
theme(plot.title = element_text(hjust = 0.5))
dev.off()
# @ shuming make a plot by the number of clusters on x axis
write.csv(db_new,paste(output_path,input_name,clust_method,"DBStats.csv",sep=""))
