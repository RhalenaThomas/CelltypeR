# select dot plot or heat map
if(plot_type == 'heatmap'){
# Heat map
print(ggplot(dt.long, aes(x = variable, y = AB)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient(low="blue", high="pink", na.value = "grey") +
labs(x=xlab, y= ylab) +
theme_bw() + theme(axis.text.x=element_text(size=12, angle=90, hjust=0.95,vjust=0.2),
axis.text.y=element_text(size=12),
plot.title=element_text(size=12)))
} else if(plot_type== 'dotplot'){
a <- DotPlot(seu, features = AB, group.by = group)
pct.exp <- as.data.frame(a$data) %>% select(features.plot, id, pct.exp)
# add the mean expression and percent cells
# rename columns to match
colnames(dt.long) <- c("Markers","id","expression")
colnames(pct.exp) <- c("Markers","id","proportion")
df.exp.pct <- merge(dt.long, pct.exp, by = c("Markers", "id"))
data <- df.exp.pct %>% mutate(Cell.type = factor(id, levels = var1order))
data <- data %>% mutate(Marker = factor(Markers, levels = var2order))
print(ggplot(data = data, aes(x = Marker, y = Cell.type, color = expression, size = proportion)) +
geom_point() +
scale_color_gradient(low = "grey", high = "blue") + ylab("Cell Phenotypes")
+ xlab("Antibodies") + RotatedAxis())
}
else {
print("not a valid plotting option")
}
}
##############################################################################################
#' Prepare a data frame for statistics
#'
#'This function takes a Seurat object and creates a data frame with the expression
#'values for each cell for each marker.  Columns are created for all the indicated
#'variables.  All the variables must exist as meta data in the Seurat object.
#'
#' @export
#' @import data.table
#' @importFrom data.table melt
Prep_for_stats <- function(seu, marker_list, variables, marker_name = 'Marker'){
# create a dataframe with all the expresson data
df <- transpose(as.data.frame(GetAssayData(seu,slot = 'scale.data')))
# rename columns
colnames(df) <- marker_list
# add the different grouping
for (i in seq_along(variables)) {
meta_data <- as.data.frame(seu@meta.data[, variables[i]])
colnames(meta_data) <- variables[i]
df <- cbind(df, meta_data)
}
# need the antibodies to also be a variable
# convert to data table to use the melt function in data.table instead of reshape2
dt <- as.data.table(df)
molten <- melt(dt, measure.vars = marker_list, variable.name = marker_name)
return(molten)
}
##############################################################################################
#' Run one-way or two-way ANOVAs and Tukey's HSD test
#'
#'This function takes a data frame prepared by "Prep_for_stats" and outputs
#'a list of ANOVA and TUKEY results. For two-way ANOVAs, stat_type = "ANOVA2". The
#'interaction effect is calculated.
#' group_cols is a vector with the columns to get the means from if use_means = NULL
#' the means will not be calculated and n = number of cells instead of samples per group.
#'id1 is the independent variable to compare (dependent variable is the expression)
#' id2 is for 2 way anova and should be Marker or Celltype but other options are possible.
#' value_col is the column name with the expression values.  This only needs to be
#' changed if the input data frame wasn't created with the "Prep_for_stats" function.
#' @export
run_stats <- function(input_df, group_cols = c("Sample", "CellType", "Marker"),
value_col = "value",
stat_type = "ANOVA",
id1,
id2 = NULL,
use_means = TRUE,
loop_by = "CellType") {
aov.l <- list() # for ANOVA output
tuk.l <- list() # for TUKEY output
if (use_means) {
df_means <- get_means(input_df, group_cols, value_col)
} else {
df_means <- input_df
names(df_means)[names(df_means) == 'value'] <- 'expression'
}
if (stat_type == "ANOVA") {
if (loop_by == "CellType") {
var_list <- unique(df_means$CellType)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(CellType == i)
one_way <- aov(expression ~ df[[id1]], data = df)
output <- summary(one_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l[[as.character(i)]] <- tukey
}
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(Celltype = names(aov.l)[i],
IndependentVariable = id1,
Fvalue = aov.l[[i]][[1]][["F value"]][1],
pValue = aov.l[[i]][[1]][["Pr(>F)"]][1],
Df = aov.l[[i]][[1]][["Df"]][1],
SumSqEffect = aov.l[[i]][[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[i]][[1]][["Mean Sq"]][1],
SumSqError = aov.l[[i]][[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[i]][[1]][["Mean Sq"]][2]
)
}
))
print(paste("ANOVA results for each cell type comparing ", id1))
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[1]])
data.frame(Celltype = names(tuk.l)[i],
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[i]][[1]], row.names = NULL)
}))
print(paste("TukeyHSD results for each cell type comparing ", id1))
} else if (loop_by == "Marker") {
var_list <- unique(df_means$Marker)
for (i in var_list) {
df <- df_means %>% filter(Marker == i)
one_way <- aov(expression ~ df[[id1]], data = df)
output <- summary(one_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l[[as.character(i)]] <- tukey
}
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(Marker = names(aov.l)[i],
IndependentVariable = id1,
Fvalue = aov.l[[i]][[1]][["F value"]][1],
pValue = aov.l[[i]][[1]][["Pr(>F)"]][1],
Df = aov.l[[i]][[1]][["Df"]][1],
SumSqEffect = aov.l[[i]][[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[i]][[1]][["Mean Sq"]][1],
SumSqError = aov.l[[i]][[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[i]][[1]][["Mean Sq"]][2]
)
}
))
print(paste("ANOVA results for each marker comparing ", id1))
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[1]])
data.frame(Marker = names(tuk.l)[i],
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[i]][[1]], row.names = NULL)}))
print(paste("Tukey results for each marker comparing ", id1))
} else {
one_way <- aov(expression ~ df_means[[id1]], data = df_means)
aov.l <- summary(one_way)
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l <- tukey
aov_df <- data.frame(
IndependentVariable = id1,
Fvalue = aov.l[[1]][["F value"]][1],
pValue = aov.l[[1]][["Pr(>F)"]][1],
Df = aov.l[[1]][["Df"]][1],
SumSqEffect = aov.l[[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[1]][["Mean Sq"]][1],
SumSqError = aov.l[[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[1]][["Mean Sq"]][2]
)
print("ANOVA results for all celltypes and markers combined")
rownames <- row.names(tuk.l[[1]])
tuk_df  <- data.frame(
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[1]], row.names = NULL)
print("TukeyHSD results for all celltypes and markers combined")
}
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_df)
}else if (stat_type == "ANOVA2") {
if (loop_by == "CellType") {
var_list <- unique(df_means$CellType)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(CellType == i)
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
output <- summary(two_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l[[as.character(i)]] <- tukey
}
# make a dataframe of the 2 way anova results
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(
rownames <- row.names(aov.l[[i]][[1]]),
data.frame(Celltype = names(aov.l)[i],
Contrast = rownames,
aov.l[[i]][[1]], row.names = NULL
)
)
}))
# get ride of the residual which will confuse things and the extra row added
aov_df <- aov_df[2:8]
# fix the column names
colnames(aov_df) <- c("Celltype","Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
print(paste("ANOVA 2way results for each cell type comparing ", id1,
"and ", id2))
# make dataframes from each of the tukey results and put them into a list
tuk_summary.l <- list()
for(J in 1:length(tuk.l[[1]])){
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[J]])
data.frame(Celltype = names(tuk.l)[i],
Contrast = names(tuk.l[[i]])[J],
Subgroups = rownames,
tuk.l[[i]][[J]], row.names = NULL)
}))
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l[[i]])[J])]] <- tuk_df
}
# filter the interaction dataframe to have only df1 contrasts
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
print(paste("TukeyHSD results for each cell type comparing ", id1,
"and ", id2))
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
} else if (loop_by == "Marker") {
var_list <- unique(df_means$Marker)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(Marker == i)
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
output <- summary(two_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l[[as.character(i)]] <- tukey
}
# make a dataframe of the 2 way anova results
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(
rownames <- row.names(aov.l[[i]][[1]]),
data.frame(Marker = names(aov.l)[i],
Contrast = rownames,
aov.l[[i]][[1]], row.names = NULL
)
)
}))
# get ride of the residual which will confuse things and the extra row added
aov_df <- aov_df[2:8]
# fix the column names
colnames(aov_df) <- c("Marker","Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
print(paste("ANOVA 2way results for each Marker comparing ", id1,
"and ", id2))
# make dataframes from each of the tukey results and put them into a list
tuk_summary.l <- list()
for(J in 1:length(tuk.l[[1]])){
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[J]])
data.frame(Marker = names(tuk.l)[i],
Contrast = names(tuk.l[[i]])[J],
Subgroups = rownames,
tuk.l[[i]][[J]], row.names = NULL)
}))
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l[[i]])[J])]] <- tuk_df
}
# filter the interaction dataframe to have only df1 contrasts
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
print(paste("TukeyHSD results for each Marker comparing ", id1,
"and ", id2))
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
} else {
df <- df_means
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
aov.l <- summary(two_way)
# make the df of the ANOVA two way results
rownames <- row.names(aov.l[[1]])
aov_df <- data.frame(
Contrast = rownames,
aov.l[[1]], row.names = NULL
)
# get ride of the residual which will confuse things and the extra row added
# fix the column names
colnames(aov_df) <- c("Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l <- tukey
print("ANOVA results for all celltypes and markers combined")
# get the Tukey outputs
for(J in 1:length(tuk.l)){
rownames <- row.names(tuk.l[[J]])
tuk_df <- data.frame(
Contrast = names(tuk.l[J]),
Subgroups = rownames,
tuk.l[[J]], row.names = NULL)
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l)[J])]] <- tuk_df
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
}
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
}
return(output_list)
}
}
#
# original get means function
get_means <- function(df, group_cols, value_col) {
df_means <- df %>%
group_by(across(all_of(group_cols))) %>%
mutate(expression = mean(value)) %>%
distinct(across(all_of(group_cols)), expression, .keep_all = TRUE) %>%
select(-value)
return(df_means)
}
reference_path <- "/Users/rhalenathomas/GITHUB/CelltypeR/Data/ReferenceMatrix9celltypesOrdered.csv"
#reference_path <- "/GITHUB/CelltypeR/Data/ReferenceMatrix9celltypesOrdered.csv"
reference_data <- read.csv(reference_path)
test_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/prepro_outsretrotransformed_flowset.csv"
test.df <- read.csv(test_path)
cor <- find_correlation(test = test.df, reference = reference_data,
min_corr = 0.45, min_diff = 0.1)
library(kit) # for topn
cor <- find_correlation(test = test.df, reference = reference_data,
min_corr = 0.45, min_diff = 0.1)
# threshold for assigning unknown is R < 0.45
# threshold for double label is R1-R2 < 0.1
View(cor)
df <- corr %>% filter(!grepl('-',cell.label))
df <- cor %>% filter(!grepl('-',cell.label))
ggplot(df, aes(x=cell.label, y=cor.1 ))+ geom_violin()+ ylim(-0.1,1)+theme_classic()+
theme(axis.text.x=element_text(angle=90)) + ylab("correlation coefficient") + xlab("Cell type with max correlation coefficient")
thresh1 <- 0.45
ggplot(df, aes(x=best.cell.type, y=cor.1, fill = best.cell.type))+ geom_violin(trim = FALSE)+ ylim(0,1)+theme_classic()+
theme(text = element_text(size = 18), axis.text.x=element_text(angle=90, size = 15)) + ylab("correlation coefficient") + xlab("Cell type with max correlation coefficient") +
geom_hline(yintercept = thresh1) +
guides(fill = guide_legend(title = "Cell Phenotype"))
df <- corr_cell.df
df <- cor
df.filter <- df %>% filter(!grepl('unknown',cell.label))
# filter for only frequent double cell types
df.filter <- df.filter %>% group_by(cell.label) %>% dplyr::filter(n()> 400)
View(df.filter)
# Figure 3A
# Plot the reference matrix for correlation
reference_path <- "/Users/rhalenathomas/GITHUB/CelltypeR/Data/ReferenceMatrix9celltypesOrdered.csv"
#reference_path <- "/GITHUB/CelltypeR/Data/ReferenceMatrix9celltypesOrdered.csv"
reference_data <- read.csv(reference_path)
test_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/prepro_outsretrotransformed_flowset.csv"
test.df <- read.csv(test_path)
library(kit) # for topn
cor <- find_correlation(test = test.df, reference = reference_data,
min_corr = 0.45, min_diff = 0.1)
cor
df <- cor %>% filter(!grepl('-',cell.label))
thresh1 <- 0.45
ggplot(df, aes(x=best.cell.type, y=cor.1, fill = best.cell.type))+ geom_violin(trim = FALSE)+ ylim(0,1)+theme_classic()+
theme(text = element_text(size = 18), axis.text.x=element_text(angle=90, size = 15)) + ylab("correlation coefficient") + xlab("Cell type with max correlation coefficient") +
geom_hline(yintercept = thresh1) +
guides(fill = guide_legend(title = "Cell Phenotype"))
#save this plot for figure 3B
# pdf(paste(output_path,"Vln.max.cor.main.cells.pdf"),height = 4, width = 6)
# ggplot(df, aes(x=best.cell.type, y=cor.1, fill = best.cell.type))+ geom_violin(trim = FALSE)+ ylim(0,1)+theme_classic()+
#    theme(text = element_text(size = 15), axis.text.x=element_text(angle=90, size = 12)) + ylab("correlation coefficient") + xlab("Cell type with max correlation coefficient") +
#   geom_hline(yintercept = thresh1) +
#   guides(fill = guide_legend(title = "Cell Phenotype"))
# dev.off()
# Figure 3 C - bar chart of the frequency of assigned cell types with cut-off freq 400
## remove the unknown cell types
df <- cor
df.filter <- df %>% filter(!grepl('unknown',cell.label))
# filter for only frequent double cell types
df.filter <- df.filter %>% group_by(cell.label) %>% dplyr::filter(n()> 400)
plot1 <- ggplot(df.filter, aes(x=reorder(cell.label,cell.label,function(x)-length(x)), fill = cell.label))+ geom_bar()+theme_classic() +
theme(text = element_text(size = 16), axis.text.x=element_text(angle=90, hjust = 1))+ xlab('Assigned cell type') + ylab('Number of cells') +
guides(fill = guide_legend(title = "Cell Phenotype"))
plot1
# pdf(paste(output_path,"BarFreq.known400plus.pdf",sep=""),width =6, height = 4)
#   plot1
# dev.off()
df <- cor
df.filter <- df %>% filter(!grepl('unknown',cell.label))
# filter for only frequent double cell types
df.filter <- df.filter %>% group_by(cell.label) %>% dplyr::filter(n()> 500)
plot1 <- ggplot(df.filter, aes(x=reorder(cell.label,cell.label,function(x)-length(x)), fill = cell.label))+ geom_bar()+theme_classic() +
theme(text = element_text(size = 16), axis.text.x=element_text(angle=90, hjust = 1))+ xlab('Assigned cell type') + ylab('Number of cells') +
guides(fill = guide_legend(title = "Cell Phenotype"))
plot1
plot_corr(cor)
df <- cor
df.filter <- df %>% filter(!grepl('unknown',cell.label))
# filter for only frequent double cell types
df.filter <- df.filter %>% group_by(cell.label) %>% dplyr::filter(n()> 500)
plot1 <- ggplot(df.filter, aes(x=reorder(cell.label,cell.label,function(x)-length(x)), fill = cell.label))+ geom_bar()+theme_classic() +
theme(text = element_text(size = 16), axis.text.x=element_text(angle=90, hjust = 1))+ xlab('Assigned cell type') + ylab('Number of cells') +
guides(fill = guide_legend(title = "Cell Phenotype"))
plot1
plot2 <- ggplot(df.filter, aes(x=cell.label, fill = cell.label))+ geom_bar()+theme_classic() +
theme(text = element_text(size = 16), axis.text.x=element_text(angle=90, hjust = 1))+ xlab('Assigned cell type') + ylab('Number of cells') +
guides(fill = guide_legend(title = "Cell Phenotype"))
plot2
plot1
seu <- readRDS("/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/9MBO/prepro_outsjan20-9000cells/Figure3/cluster_parameters/retro-louv-moreparm/retrotransLouvainSeuratObject60.Rds")
AB <- c("CD24","CD56","CD71","CD29","CD15", "CD184","CD133", "GLAST","CD44","AQP4","HepaCAM","CD140a", "O4" )
DimPlot(seu, reduction = "umap", label = TRUE, group.by = 'RNA_snn_res.0.7', repel = TRUE)
colnames(seu@meta.data)
Idents(seu) <- "RNA_snn_res.0.7"
cluster.ids <- c("LowLabel","Neuron-Glia","Neurons1","RG1","Epi1","Epi-Astro","Neu-OPC","RG-Astro",
"Astro","Astro-m","Neurons2","Mix-early-Neu","RG2","RG3","endo","oligo","stem-epi","stem",
"neuralstem")
names(cluster.ids) <- levels(seu)
seu <- RenameIdents(seu, cluster.ids)
seu$labels <- Idents(seu)
# with more subgroups
Idents(seu) <- "RNA_snn_res.0.7"
cluster.ids <- c("Unknown","Mixed","Neurons 1","Radial Glia 1","Epithelial","Astrocytes 1","Neurons 2","Astrocytes 1",
"Astrocytes 1","Astrocytes 2","Neurons 2","NPC","Radial Glia 2",
"Radial Glia 2","Endothelial","Oligodendrocytes","Stem cell like","Stem cell like",
"Stem cell like")
names(cluster.ids) <- levels(seu)
seu <- RenameIdents(seu, cluster.ids)
seu$cell.types <- Idents(seu)
DimPlot(seu, reduction = "umap", label = TRUE, group.by = 'cell.types', repel = TRUE)
# there are 13 levels in the cell type annatotion with major groups
# change the order of the cell types on the legend of the umap
cell.type.order <- c("Astrocytes 1", "Astrocytes 2","Radial Glia 1","Radial Glia 2",
"Epithelial","Endothelial","NPC","Neurons 1","Neurons 2",
"Oligodendrocytes","Stem cell like","Mixed","Unknown")
cell.type.order <- rev(cell.type.order)
# colour order to match cell type order
clust.colours <- c("chocolate1","orange","lightsalmon", "pink",
"steelblue3","deepskyblue","plum3","purple","orchid2",
"seagreen3","tomato3","burlywood3","grey90")
DimPlot(seu, order = cell.type.order, cols = clust.colours, shuffle = TRUE, raster=TRUE,pt.size = 0.1, label = FALSE) +
theme(legend.text = element_text(size=24), axis.title.y = element_text(size=24),
axis.title.x = element_text(size=24), axis.text.y = element_text(size =24),
axis.text.x = element_text(size =24))
#dev.off()
# png(paste(output_path,"UMAPlabelled9000.08072022.norater.png"),width = 1100, height = 600)
DimPlot(seu, order = cell.type.order, cols = clust.colours, shuffle = TRUE, raster=FALSE,pt.size = 0.05, label = FALSE) +
theme(legend.text = element_text(size=24), axis.title.y = element_text(size=24),
axis.title.x = element_text(size=24), axis.text.y = element_text(size =24),
axis.text.x = element_text(size =24))
#dev.off()
# use PDF for figure for correct resolution
# pdf(paste(output_path,"UMAPlabelled9000.08072022.noraster.pdf"),width = 10, height = 5)
# DimPlot(seu, order = cell.type.order, cols = clust.colours, shuffle = TRUE, raster=FALSE,pt.size = 0.1, label = FALSE) +
#   theme(legend.text = element_text(size=24), axis.title.y = element_text(size=24),
#         axis.title.x = element_text(size=24), axis.text.y = element_text(size =24),
#         axis.text.x = element_text(size =24))
# dev.off()
DimPlot(seu, order = cell.type.order, cols = clust.colours, shuffle = TRUE, raster=FALSE,pt.size = 0.1, label = TRUE)
=
DimPlot(seu, order = cell.type.order, cols = clust.colours, shuffle = TRUE, raster=FALSE,pt.size = 0.1, label = TRUE)
DimPlot(seu, order = cell.type.order, cols = clust.colours, shuffle = TRUE, raster=FALSE,pt.size = 0.1, label = TRUE)
######## figure 3E heatmap of the
# reorder the bars to match the UMAP
levels(seu) <- c("Astrocytes 1", "Astrocytes 2","Radial Glia 1","Radial Glia 2",
"Epithelial","Endothelial","NPC","Neurons 1","Neurons 2",
"Oligodendrocytes","Stem cell like","Mixed","Unknown")
#pdf(paste(output_path,"HM9000.08072022.pdf"),width = 8, height = 5)
DoHeatmap(seu, features = AB, size= 6,slot = "scale.data", group.colors = clust.colours, disp.max = 2, disp.min = -1.5,
angle = 90) + scale_fill_gradientn(colors = c("#154c79", "#eeeee4", "#e28743")) +
theme(axis.text.y = element_text(size = 15))
