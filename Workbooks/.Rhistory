filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
View(tuk_summary.l)
run_stats <- function(input_df, group_cols = c("Sample", "CellType", "Marker"),
value_col = "value",
stat_type = "ANOVA",
id1,
id2 = NULL,
use_means = TRUE,
loop_by = "CellType") {
aov.l <- list() # for ANOVA output
tuk.l <- list() # for TUKEY output
if (use_means) {
df_means <- get_means(input_df, group_cols, value_col)
} else {
df_means <- input_df
names(df_means)[names(df_means) == 'value'] <- 'expression'
}
if (stat_type == "ANOVA") {
if (loop_by == "CellType") {
var_list <- unique(df_means$CellType)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(CellType == i)
one_way <- aov(expression ~ df[[id1]], data = df)
output <- summary(one_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l[[as.character(i)]] <- tukey
}
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(Celltype = names(aov.l)[i],
IndependentVariable = id1,
Fvalue = aov.l[[i]][[1]][["F value"]][1],
pValue = aov.l[[i]][[1]][["Pr(>F)"]][1],
Df = aov.l[[i]][[1]][["Df"]][1],
SumSqEffect = aov.l[[i]][[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[i]][[1]][["Mean Sq"]][1],
SumSqError = aov.l[[i]][[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[i]][[1]][["Mean Sq"]][2]
)
}
))
print(paste("ANOVA results for each cell type comparing ", id1))
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[1]])
data.frame(Celltype = names(tuk.l)[i],
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[i]][[1]], row.names = NULL)
}))
print(paste("TukeyHSD results for each cell type comparing ", id1))
} else if (loop_by == "Marker") {
var_list <- unique(df_means$Marker)
for (i in var_list) {
df <- df_means %>% filter(Marker == i)
one_way <- aov(expression ~ df[[id1]], data = df)
output <- summary(one_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l[[as.character(i)]] <- tukey
}
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(Marker = names(aov.l)[i],
IndependentVariable = id1,
Fvalue = aov.l[[i]][[1]][["F value"]][1],
pValue = aov.l[[i]][[1]][["Pr(>F)"]][1],
Df = aov.l[[i]][[1]][["Df"]][1],
SumSqEffect = aov.l[[i]][[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[i]][[1]][["Mean Sq"]][1],
SumSqError = aov.l[[i]][[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[i]][[1]][["Mean Sq"]][2]
)
}
))
print(paste("ANOVA results for each marker comparing ", id1))
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[1]])
data.frame(Marker = names(tuk.l)[i],
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[i]][[1]], row.names = NULL)}))
print(paste("Tukey results for each marker comparing ", id1))
} else {
one_way <- aov(expression ~ df_means[[id1]], data = df_means)
aov.l <- summary(one_way)
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l <- tukey
aov_df <- data.frame(
IndependentVariable = id1,
Fvalue = aov.l[[1]][["F value"]][1],
pValue = aov.l[[1]][["Pr(>F)"]][1],
Df = aov.l[[1]][["Df"]][1],
SumSqEffect = aov.l[[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[1]][["Mean Sq"]][1],
SumSqError = aov.l[[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[1]][["Mean Sq"]][2]
)
print("ANOVA results for all celltypes and markers combined")
rownames <- row.names(tuk.l[[1]])
tuk_df  <- data.frame(
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[1]], row.names = NULL)
print("TukeyHSD results for all celltypes and markers combined")
}
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_df)
}else if (stat_type == "ANOVA2") {
if (loop_by == "CellType") {
var_list <- unique(df_means$CellType)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(CellType == i)
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
output <- summary(two_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l[[as.character(i)]] <- tukey
}
# make a dataframe of the 2 way anova results
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(
rownames <- row.names(aov.l[[i]][[1]]),
data.frame(Celltype = names(aov.l)[i],
Contrast = rownames,
aov.l[[i]][[1]], row.names = NULL
)
)
}))
# get ride of the residual which will confuse things and the extra row added
aov_df <- aov_df[2:8]
# fix the column names
colnames(aov_df) <- c("Celltype","Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
print(paste("ANOVA 2way results for each cell type comparing ", id1,
"and ", id2))
# make dataframes from each of the tukey results and put them into a list
tuk_summary.l <- list()
for(J in 1:length(tuk.l[[1]])){
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[J]])
data.frame(Celltype = names(tuk.l)[i],
Contrast = names(tuk.l[[i]])[J],
Subgroups = rownames,
tuk.l[[i]][[J]], row.names = NULL)
}))
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l[[i]])[J])]] <- tuk_df
}
# filter the interaction dataframe to have only df1 contrasts
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
print(paste("TukeyHSD results for each cell type comparing ", id1,
"and ", id2))
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
} else if (loop_by == "Marker") {
var_list <- unique(df_means$Marker)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(Marker == i)
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
output <- summary(two_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l[[as.character(i)]] <- tukey
}
# make a dataframe of the 2 way anova results
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(
rownames <- row.names(aov.l[[i]][[1]]),
data.frame(Marker = names(aov.l)[i],
Contrast = rownames,
aov.l[[i]][[1]], row.names = NULL
)
)
}))
# get ride of the residual which will confuse things and the extra row added
aov_df <- aov_df[2:8]
# fix the column names
colnames(aov_df) <- c("Marker","Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
print(paste("ANOVA 2way results for each Marker comparing ", id1,
"and ", id2))
# make dataframes from each of the tukey results and put them into a list
tuk_summary.l <- list()
for(J in 1:length(tuk.l[[1]])){
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[J]])
data.frame(Marker = names(tuk.l)[i],
Contrast = names(tuk.l[[i]])[J],
Subgroups = rownames,
tuk.l[[i]][[J]], row.names = NULL)
}))
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l[[i]])[J])]] <- tuk_df
}
# filter the interaction dataframe to have only df1 contrasts
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
print(paste("TukeyHSD results for each Marker comparing ", id1,
"and ", id2))
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
} else {
df <- df_means
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
aov.l <- summary(two_way)
# make the df of the ANOVA two way results
rownames <- row.names(aov.l[[1]])
aov_df <- data.frame(
Contrast = rownames,
aov.l[[1]], row.names = NULL
)
# get ride of the residual which will confuse things and the extra row added
# fix the column names
colnames(aov_df) <- c("Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l <- tukey
print("ANOVA results for all celltypes and markers combined")
# get the Tukey outputs
for(J in 1:length(tuk.l)){
rownames <- row.names(tuk.l[[J]])
tuk_df <- data.frame(
Contrast = names(tuk.l[J]),
Subgroups = rownames,
tuk.l[[J]], row.names = NULL)
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l)[J])]] <- tuk_df
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
}
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
}
return(output_list)
}
}
#
# original get means function
get_means <- function(df, group_cols, value_col) {
df_means <- df %>%
group_by(across(all_of(group_cols))) %>%
mutate(expression = mean(value)) %>%
distinct(across(all_of(group_cols)), expression, .keep_all = TRUE) %>%
select(-value)
return(df_means)
}
test.stats5 <- run_stats(input_df= df.for.stats, group_cols = c("Sample", "CellType","Marker","Genotype","Batch"),
value_col = "value",
stat_type = "ANOVA2", id1 = 'Genotype',
id2 = "Marker", use_means = TRUE,
loop_by = "CellType")
# see the relevant interactions Tukey's results
df <- as.data.frame(test.stats1[["TukeyHSD"]][["Interactions_ Genotype"]])
head(df)
# now filter for significant differences
df_sig <- df %>% filter(p.adj < 0.05)
View(test.stats5)
df <- as.data.frame(test.stats1[["TukeyHSD"]][["Interactions_ Genotype"]])
head(df)
df <- as.data.frame(test.stats5[["TukeyHSD"]][["Interactions_ Genotype"]])
head(df)
# now filter for significant differences
df_sig <- df %>% filter(p.adj < 0.05)
df_sig
test.stats6 <- run_stats(input_df= df.for.stats, group_cols = c("Sample", "CellType","Marker","Genotype","Batch"),
value_col = "value",
stat_type = "ANOVA2", id1 = 'Genotype',
id2 = "CellType", use_means = TRUE,
loop_by = "Marker")
# see the interactions Tukey's results where id1 or id2 match
df <- as.data.frame(test.stats6[["TukeyHSD"]][["Interactions_ Genotype"]])
head(df)
# now filter for significant differences
df_sig <- df %>% filter(p.adj < 0.05)
df_sig
df <- as.data.frame(test.stats2[["TukeyHSD"]][["Interactions_ CellType"]])
head(df)
# now filter for significant differences
df_sig <- df %>% filter(p.adj < 0.05)
head(df)
df <- as.data.frame(test.stats6[["TukeyHSD"]][["Interactions_ Genotype"]])
head(df)
# now filter for significant differences
df_sig <- df %>% filter(p.adj < 0.05)
df_sig
df <- as.data.frame(test.stats6[["TukeyHSD"]][["Interactions_ CellType"]])
head(df)
# now filter for significant differences
df_sig <- df %>% filter(p.adj < 0.05)
df_sig
5+6
rf <- RFM_train(seurate_object = seu,
AB_list = AB, annotations = seu$CellType,
split = c(0.8,0.2),
downsample = NULL,
seed = 222,
mytry = c(1:10),
maxnodes = c(12: 25),
trees = c(250, 500, 1000,2000),
start_node = 15)
rf <- RFM_train(seurate_object = seu,
AB_list = AB, annotations = seu$CellType,
split = c(0.8,0.2),
downsample = "none",
seed = 222,
mytry = c(1:10),
maxnodes = c(12: 25),
trees = c(250, 500, 1000,2000),
start_node = 15)
#save(rf, output_path,"trainedRFM.Rds")
40000/80
2000/24
2000*24
48000/2000
1000000/96
100000/48
2000*43.1
17000/13
library(Seurat)
library(tidyverse)
seu8 <- readRDS("/Users/rhalenathomas/Documents/Data/scRNAseq/Darkgenome/6weeks/step8/objs/seu_step8.rds")
FeaturePlot(seu8, features = c("SOX2", "CALB1"), label = TRUE)
FeaturePlot(seu8, features = c("NGN1", "NGN2"), label = TRUE)
FeaturePlot(seu8, features = c("NEUROG1", "NEUROG2"), label = TRUE)
FeaturePlot(seu8, features = c("MKI67","PCNA","NES"), label = TRUE)
FeaturePlot(seu8, features = c("MKI67","PCNA","NES"), label = FALSE)
FeaturePlot(seu8, features = c("S100B","SLC1A3","ALDH1L1")) # none
FeaturePlot(seu8, features = c("LMX1A","LMX1B","EN1","PITX3","NR4A1"), label = FALSE)
FeaturePlot(seu8, features = c("LMX1A","LMX1B","EN1","PITX3","NR4A2"), label = FALSE)
Idents(seu8) <- 'integrated_snn_res.0.7'
FeaturePlot(seu8, features = c("VIM","GFAP","AQP4")) # none
FeaturePlot(seu8, features = c("S100B","SLC1A3","ALDH1L1"))
FeaturePlot(seu8, features = c("RBFOX3","MAP2","SNAP25")) # Neuron
# we see maturen on the left
FeaturePlot(seu8, features = c("MOG","MBP","OLIG1")) # none
FeaturePlot(seu8, features = c("SLC32A1","GAD1","GAD2")) # GABA cluster 5
FeaturePlot(seu8, features = c("DDC","TH","SLC6A3","SLC18A2")) # DA cluster 13
FeaturePlot(seu8, features = c("TPH1","TPH2","SLC6A4"))
FeaturePlot(seu8, features = c("SLC17A6", "SLC17A7"), label = TRUE)
FeaturePlot(seu8, features = c("SOX2", "CALB1"), label = TRUE)
FeaturePlot(seu8, features = c("NEUROG1", "NEUROG2"), label = TRUE)
FeaturePlot(seu8, features = c("MKI67","PCNA","NES"), label = FALSE)
FeaturePlot(seu8, features = c("LMX1A","LMX1B","EN1","PITX3","NR4A2"), label = FALSE)
View(seu8)
DimPlot(seu8, group.by = "integrated_snn_res.0.1")
View(seu8)
DimPlot(seu8, group.by = "integrated_snn_res.0.2")
# level for broad annotations
Sys.time()
library(Seurat)
library(tidyverse)
library(DoubletFinder)
wd <- "/Users/rhalenathomas/Documents/scRNAclubMcGill/workshop2023/data/"
setwd(wd)
adolescent_data <- Read10X("Adolescent_14_YO_raw_feature_bc_matrix/",
strip.suffix = TRUE )
# load data
# insert the pathway to the location of the data
# Windows
setwd("C:/Users/Home/Documents/GitHub/SingleCell_Workshop/") # run in terminal directly
# load data
# insert the pathway to the location of the data
# Windows
#setwd("C:/Users/Home/Documents/GitHub/SingleCell_Workshop/") # run in terminal directly
# MAC/Linux
wd <- "/Users/rhalenathomas/Documents/scRNAclubMcGill/workshop2023/data/"
setwd(wd)
adolescent_data <- Read10X("Adolescent_14_YO_raw_feature_bc_matrix/",
strip.suffix = TRUE )
#Look at the dimensions of the matrix
dim(adolescent_data)
#Look at a small part of the data
adolescent_data[1:5, 1:5]
#Look at the distribution of the number of UMIs per cell
colSums(adolescent_data) %>% summary
#Look at the distribution of the number of genes per cell
colSums(adolescent_data > 0) %>% summary
input_path <- "/Users/rhalenathomas/Documents/Data/scRNAseq/PublicData/"
CO <- readRDS(paste(input_path,"org_exp_UCSC.rds",sep = ""))
class(CO)
# load libraries
library(tidyverse)
library(ggplot2)
library(Seurat)
desired_cells = 50000
sampled_cols <- sample(ncol(CO), size = desired_cells, replace = FALSE)
# Subset the data.table using the sampled column indices
COsub <- CO[, sampled_cols, with = FALSE]
memory.limit()
ulimit -a | grep "max memory size"
mem_used()
# load libraries
library(tidyverse)
library(ggplot2)
library(Seurat)
library(pryr) # for memory check
mem_used()
input_path <- "/Users/rhalenathomas/Documents/Data/scRNAseq/PublicData/"
CO <- readRDS(paste(input_path,"orgUCSCexp50000cells.csv",sep = ""))
CO <- read.csv(paste(input_path,"orgUCSCexp50000cells.csv",sep = ""))
class(CO)
dim(CO)
mem_used()
col_names <- as.character(colnames(CO))
row_names <- as.character(rownames(CO))
# Create Seurat object directly from the data.table
so <- CreateSeuratObject(counts = CO, barcodes = col_names, genes = row_names)
meta <- read.table(paste(input_path,"meta_USCSorganoids.tsv",sep=""),header=T, sep="\t", as.is=T, row.names=1)
View(so)
CO[1:5,1:3]
input_path <- "/Users/rhalenathomas/Documents/Data/scRNAseq/PublicData/"
CO <- readRDS(paste(input_path,"org_exp_UCSC.rds",sep = ""))
class(CO)
desired_cells = 50000
sampled_cols <- sample(ncol(CO), size = desired_cells, replace = FALSE)
COsub <- CO %>%
select(all_of(sampled_cols))
dim(COsub)
COsub[1:5,1:3]
genes = CO[,1][[1]]
genes = gsub(".+[|]", "", genes)
mat = data.frame(CO[,-1], row.names=genes)
COsub <- CO[, -1, with = FALSE]
# Set the "gene" column as row names
setrownames(COsub, CO$gene)
COsub <- COsub[, -"gene", with = FALSE]
mem_used()
rm(COsub)
mem_used()
gc() # try to free memory
mem_used()
rm(genes,input_path,sampled_cols)
mem_used()
input_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/TimeCourseAIW/LiveCells"
output_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/TimeCourseAIW/Analysis/"
# 1.a Read in FlowJo Files
# down sample to take cells from each of 4 time points and 4 replicates
flowset <- fsc_to_fs(input_path)
devtools::install_github("RhalenaThomas/CelltypeR/CelltypeR")
# load necessary libraries
library(Seurat)
library(Seurat)
library(tidyverse)
NPCex1 <- readRDS("/Users/rhalenathomas/Documents/Data/scRNAseq/ParseExample/NPCex1.RDS")
NPCex2 <- readRDS("/Users/rhalenathomas/Documents/Data/scRNAseq/ParseExample/NPCex2.RDS")
seu <- merge(NPCex1, NPCex2)
unique(seu$orig.ident)
seurat_list <- SplitObject(seu, split.by = "orig.ident")
saveRDS(seurat_list,"/Users/rhalenathomas/Documents/Data/scRNAseq/ParseExample/NPCex1_ex2_list.RDS")
int.anchors <- FindIntegrationAnchors(object.list = seurat_list, dims = 1:25,
anchor.features = 1000)
?library()
?install.packages()
