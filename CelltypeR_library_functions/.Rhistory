}
else{
print("filtering")
t.lab.known <- t.lables %>% dplyr::filter(!(Label %in% filter_out))
top.lab <- t.lab.known  %>% group_by(Cluster) %>% top_n(1, Freq)
#top.lab <- t.lab.known %>%
#  group_by(Cluster) %>%
#  mutate(rank = dense_rank(desc(Freq))) %>%
# filter(rank == 1) %>%
#  select(-rank)
sort.tops <- top.lab %>% as.data.frame() %>% arrange(desc(Freq))  %>% arrange(Cluster)
}
ann.df <- sort.tops %>% select(-"Freq")
colnames(ann.df) <- c("Cluster", Label)
return(ann.df)
}
## example
# input arguments
#seu.clusters <- seu.t$RNA_snn_res.0.8   # cluster resolution to label
#seu.lable <- seu.t$cor.labels   # predicted labels per cell meta data slot
# top number of cell type labels. This will only be for the printed table
# the top most frequently label will be used for cluster annotation
# ignore unknow is an option to filter out unknown cells and then the next more frequently
# predicted cell type will be used.
#ann_cor <- get_annotation(seu.t, seu.clusters, seu.lable, top_n = 3, ignore_unknown = FALSE)
##############################################################################################
# cluster_annotate
# input dfs of cluster annotation, at least 1 is required
# dfs were created with get_annotation function
# manual annotation can be df as well.  Make in excel read in csv or create
# type manually, be careful to match syntax to the other predictions
# input seurat data object
# finds most common label per cluster and applies that label
cluster_annotate <- function(seu, ann.list,
annotation_name,
to_label){
# not all annotations methods will always present
# easiest to make the input a list
df.merge <- Reduce(function(x,y) merge(x,y, by="Cluster", all = TRUE),
ann.list)
# convert all to lowercase
df2 <- lapply(df.merge, function(x) {tolower(as.character(x))})
# back into a dataframe
df3 <- as.data.frame(do.call(cbind, df2))
df3$consensus <- apply(df3, 1, function(row) {
if (is.data.frame(row)) {
word_counts <- table(unlist(row[,2:ncol(row)]))
} else if (is.matrix(row)) {
word_counts <- table(unlist(row))
} else {
word_counts <- table(unlist(c(row)))
}
names(word_counts)[which.max(word_counts)]
})
# now reorder by cluster number
df3$Cluster <- as.integer(as.character(df3$Cluster))
dfsort <- df3  %>% arrange(Cluster)
# get a vector
dfcon <- dfsort %>% dplyr::select("Cluster","consensus")
print(dfcon)
# now add the annotations into the seurat
# use the simple annnotation function
seu <- annotate(seu, annotations = dfcon$consensus, to_label,
annotation_name)
}
annotate <- function(seu, annotations, to_label, annotation_name = "CellType"){
Idents(seu) <- to_label
names(annotations) <- levels(seu)
seu <- RenameIdents(seu, annotations)
seu <- AddMetaData(object=seu, metadata=Idents(seu), col.name = annotation_name)
}
######### functions to compare groups in an annotated seurat object ################
# plotting function
proportionplots <- function(seu, seu.var, seu.lable, groups = "Sample", my_colours= "default"){
sample.lables <- as.data.frame(table(seu.var, seu.lable))
sample.lables$Freq <- as.double(sample.lables$Freq)
check <- length(unique(sample.lables$seu.lable))
print(paste("Number of colours needed",check, sep = ""))
print(paste("Number of colours entered ", length(my_colours), sep = ""))
if (length(my_colours) < check){
# bar chart of with percent
print("Default ggplot colours used")
print(ggplot(sample.lables, aes(x = seu.var,y=Freq ,fill = seu.lable)) +
geom_bar(position= "fill", stat = "identity") +
scale_y_continuous(labels = scales::percent_format()) +
theme_classic() +
theme(text = element_text(size=15),
axis.text.x = element_text(angle=90, hjust=1))
+ xlab(groups) + ylab('Percent of Cell type') + RotatedAxis())
}else {
# bar chart of with percent
print("Custome colours used.")
print(ggplot(sample.lables, aes(x = seu.var,y=Freq ,fill = seu.lable)) +
geom_bar(position= "fill", stat = "identity") +
scale_y_continuous(labels = scales::percent_format()) +
scale_fill_manual(values = my_colours)+
theme_classic() +
theme(text = element_text(size=15),
axis.text.x = element_text(angle=90, hjust=1))
+ xlab(groups) + ylab('Percent of Cell type') + RotatedAxis())
}
}
# run plotting function on list of variables
plotproportions <- function(seu, var.list, xgroup, varnames, my_colours = 'default'){
for (i in seq_along(var.list)) {
var <- var.list[[i]]
proportionplots(seu = seu, seu.var = var, seu.lable = xgroup, groups = varnames[i], my_colours = my_colours)
}
}
# var.list is a list defining seurat metadata slots
# xgroup is the cell types or x axis grouping variable
# varnames is a character vector of labels for the x axis of the plots
# Example
# plotproportions(seu.q, var.list = var.list, xgroup = seu.q$cell.types, varnames = varnames)
# can input costume colours
# later --- add in define sample order
### dotplots and heatmaps mean expression by group
plotmean <- function(plot_type = 'heatmap',seu, group, markers, var_names, slot = 'scale.data',
xlab = 'Cell Types', ylab = 'Antibodies', var1order, var2order){
express.by.cluster <- as.data.frame(AverageExpression(seu, features = markers,
group.by = group, slot = 'scale.data'))
express.by.cluster <- as.data.frame(scale(express.by.cluster))
if(length(var_names) < 0){
col.names <- colnames(express.by.cluster)
}else{
col.names <- var_names
}
names(express.by.cluster) <- col.names
AB <- row.names(express.by.cluster)
ex.data <- cbind(AB,express.by.cluster)
# must make a data table because melt is
dt <- data.table(ex.data)
dt.long<- melt(dt, id.vars = "AB")
# select dot plot or heat map
if(plot_type == 'heatmap'){
# Heat map
print(ggplot(dt.long, aes(x = variable, y = AB)) +
geom_raster(aes(fill=value)) +
scale_fill_gradient(low="blue", high="pink", na.value = "grey") +
labs(x=xlab, y= ylab) +
theme_bw() + theme(axis.text.x=element_text(size=12, angle=90, hjust=0.95,vjust=0.2),
axis.text.y=element_text(size=12),
plot.title=element_text(size=12)))
} else if(plot_type== 'dotplot'){
a <- DotPlot(seu, features = AB, group.by = group)
pct.exp <- as.data.frame(a$data) %>% select(features.plot, id, pct.exp)
# add the mean expression and percent cells
# rename columns to match
colnames(dt.long) <- c("Markers","id","expression")
colnames(pct.exp) <- c("Markers","id","proportion")
df.exp.pct <- merge(dt.long, pct.exp, by = c("Markers", "id"))
data <- df.exp.pct %>% mutate(Cell.type = factor(id, levels = var1order))
data <- data %>% mutate(Marker = factor(Markers, levels = var2order))
print(ggplot(data = data, aes(x = Marker, y = Cell.type, color = expression, size = proportion)) +
geom_point() +
scale_color_gradient(low = "grey", high = "blue") + ylab("Cell Phenotypes")
+ xlab("Antibodies") + RotatedAxis())
}
else {
print("not a valid plotting option")
}
}
# compare groups functions
# prep_for_stats
# run_stats
# make plots
##############################################################################################
# prep_for_stats
# input seurat object
# arguments input all variable that might be compared and where to find these variables
# Selects expression data from Seurat object organized by designated variables
require(data.table)
Prep_for_stats <- function(seu, marker_list, variables, marker_name = 'Marker'){
# create a dataframe with all the expresson data
df <- transpose(as.data.frame(GetAssayData(seu,slot = 'scale.data')))
# rename columns
colnames(df) <- marker_list
# add the different grouping
for (i in seq_along(variables)) {
meta_data <- as.data.frame(seu@meta.data[, variables[i]])
colnames(meta_data) <- variables[i]
df <- cbind(df, meta_data)
}
# need the antibodies to also be a variable
# convert to data table to use the melt function in data.table instead of reshape2
dt <- as.data.table(df)
molten <- melt(dt, measure.vars = marker_list, variable.name = marker_name)
return(molten)
}
##############################################################################################
# run_stats
# takes in dataframe from prep_for_stats
# arguments, variables, level1, level2
# runs 2way anova and posthoc tests
# outputs tables in a list
# anovas
# posthoc tukey's main
# tukey's interaction effects filtered matching sets of interest
# tables  filtered by significance
### for using sample means
# group_cols is a vector with the columns to get the means from
# where id1 is the independent variable to compare (dependent variable is the expression)
# id2 is for 2 way anova and should be Marker or Celltype,
# but other options are possible
## try getting results DF possible list of DF
## new
library(dplyr)
run_stats <- function(input_df, group_cols = c("Sample", "CellType", "Marker"),
value_col = "value",
stat_type = "ANOVA",
id1,
id2 = NULL,
use_means = TRUE,
loop_by = "CellType") {
aov.l <- list() # for ANOVA output
tuk.l <- list() # for TUKEY output
if (use_means) {
df_means <- get_means(input_df, group_cols, value_col)
} else {
df_means <- input_df
names(df_means)[names(df_means) == 'value'] <- 'expression'
}
if (stat_type == "ANOVA") {
if (loop_by == "CellType") {
var_list <- unique(df_means$CellType)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(CellType == i)
one_way <- aov(expression ~ df[[id1]], data = df)
output <- summary(one_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l[[as.character(i)]] <- tukey
}
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(Celltype = names(aov.l)[i],
IndependentVariable = id1,
Fvalue = aov.l[[i]][[1]][["F value"]][1],
pValue = aov.l[[i]][[1]][["Pr(>F)"]][1],
Df = aov.l[[i]][[1]][["Df"]][1],
SumSqEffect = aov.l[[i]][[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[i]][[1]][["Mean Sq"]][1],
SumSqError = aov.l[[i]][[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[i]][[1]][["Mean Sq"]][2]
)
}
))
print(paste("ANOVA results for each cell type comparing ", id1))
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[1]])
data.frame(Celltype = names(tuk.l)[i],
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[i]][[1]], row.names = NULL)
}))
print(paste("TukeyHSD results for each cell type comparing ", id1))
} else if (loop_by == "Marker") {
var_list <- unique(df_means$Marker)
for (i in var_list) {
df <- df_means %>% filter(Marker == i)
one_way <- aov(expression ~ df[[id1]], data = df)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l[[as.character(i)]] <- tukey
}
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(Marker = names(aov.l)[i],
IndependentVariable = id1,
Fvalue = aov.l[[i]][[1]][["F value"]][1],
pValue = aov.l[[i]][[1]][["Pr(>F)"]][1],
Df = aov.l[[i]][[1]][["Df"]][1],
SumSqEffect = aov.l[[i]][[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[i]][[1]][["Mean Sq"]][1],
SumSqError = aov.l[[i]][[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[i]][[1]][["Mean Sq"]][2]
)
}
))
print(paste("ANOVA results for each marker comparing ", id1))
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[1]])
data.frame(Marker = names(tuk.l)[i],
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[i]][[1]], row.names = NULL)}))
print(paste("Tukey results for each marker comparing ", id1))
} else {
one_way <- aov(expression ~ df_means[[id1]], data = df_means)
aov.l <- summary(one_way)
# now the posthoc test
tukey <- TukeyHSD(one_way)
tuk.l <- tukey
aov_df <- data.frame(
IndependentVariable = id1,
Fvalue = aov.l[[1]][["F value"]][1],
pValue = aov.l[[1]][["Pr(>F)"]][1],
Df = aov.l[[1]][["Df"]][1],
SumSqEffect = aov.l[[1]][["Sum Sq"]][1],
MeanSqEffect = aov.l[[1]][["Mean Sq"]][1],
SumSqError = aov.l[[1]][["Sum Sq"]][2],
MeanSqError = aov.l[[1]][["Mean Sq"]][2]
)
print("ANOVA results for all celltypes and markers combined")
rownames <- row.names(tuk.l[[1]])
tuk_df  <- data.frame(
IndependentVariable = id1,
Contrast = rownames,
tuk.l[[1]], row.names = NULL)
print("TukeyHSD results for all celltypes and markers combined")
}
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_df)
}else if (stat_type == "ANOVA2") {
if (loop_by == "CellType") {
var_list <- unique(df_means$CellType)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(CellType == i)
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
output <- summary(two_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l[[as.character(i)]] <- tukey
}
# make a dataframe of the 2 way anova results
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(
rownames <- row.names(aov.l[[i]][[1]]),
data.frame(Celltype = names(aov.l)[i],
Contrast = rownames,
aov.l[[i]][[1]], row.names = NULL
)
)
}))
# get ride of the residual which will confuse things and the extra row added
aov_df <- aov_df[2:8]
# fix the column names
colnames(aov_df) <- c("Celltype","Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
print(paste("ANOVA 2way results for each cell type comparing ", id1,
"and ", id2))
# make dataframes from each of the tukey results and put them into a list
tuk_summary.l <- list()
for(J in 1:length(tuk.l[[1]])){
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[J]])
data.frame(Celltype = names(tuk.l)[i],
Contrast = names(tuk.l[[i]])[J],
Subgroups = rownames,
tuk.l[[i]][[J]], row.names = NULL)
}))
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l[[i]])[J])]] <- tuk_df
}
# filter the interaction dataframe to have only df1 contrasts
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
print(paste("TukeyHSD results for each cell type comparing ", id1,
"and ", id2))
} else if (loop_by == "Marker") {
var_list <- unique(df_means$Marker)
# to store outputs and format in a readable way
for (i in var_list) {
df <- df_means %>% filter(Marker == i)
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
output <- summary(two_way)
aov.l[[as.character(i)]] <- output # Append output to list
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l[[as.character(i)]] <- tukey
}
# make a dataframe of the 2 way anova results
aov_df <- do.call(rbind, lapply(seq_along(aov.l), function(i) {
data.frame(
rownames <- row.names(aov.l[[i]][[1]]),
data.frame(Marker = names(aov.l)[i],
Contrast = rownames,
aov.l[[i]][[1]], row.names = NULL
)
)
}))
# get ride of the residual which will confuse things and the extra row added
aov_df <- aov_df[2:8]
# fix the column names
colnames(aov_df) <- c("Marker","Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
print(paste("ANOVA 2way results for each Marker comparing ", id1,
"and ", id2))
# make dataframes from each of the tukey results and put them into a list
tuk_summary.l <- list()
for(J in 1:length(tuk.l[[1]])){
tuk_df <- do.call(rbind, lapply(seq_along(tuk.l), function(i){
rownames <- row.names(tuk.l[[i]][[J]])
data.frame(Marker = names(tuk.l)[i],
Contrast = names(tuk.l[[i]])[J],
Subgroups = rownames,
tuk.l[[i]][[J]], row.names = NULL)
}))
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l[[i]])[J])]] <- tuk_df
}
# filter the interaction dataframe to have only df1 contrasts
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
print(paste("TukeyHSD results for each Marker comparing ", id1,
"and ", id2))
} else {
df <- df_means
formula <- as.formula(paste0("expression ~ ", id1, "*", id2))
two_way <- aov(formula, data = df)
aov.l <- summary(two_way)
# make the df of the ANOVA two way results
rownames <- row.names(aov.l[[1]])
aov_df <- data.frame(
Contrast = rownames,
aov.l[[1]], row.names = NULL
)
# get ride of the residual which will confuse things and the extra row added
# fix the column names
colnames(aov_df) <- c("Contrast","Df","SumSq","MeanSq",
"Fvalue","Pvalue")
# remove extra spaces
aov_df <- aov_df %>% mutate_all(trimws)
# remove residuals
aov_df <- aov_df[aov_df$Contrast != "Residuals", ]
# now the posthoc test
tukey <- TukeyHSD(two_way)
tuk.l <- tukey
print("ANOVA results for all celltypes and markers combined")
# get the Tukey outputs
for(J in 1:length(tuk.l)){
rownames <- row.names(tuk.l[[J]])
tuk_df <- data.frame(
Contrast = names(tuk.l[J]),
Subgroups = rownames,
tuk.l[[J]], row.names = NULL)
# put the dataframe in a list
tuk_summary.l[[as.character(names(tuk.l)[J])]] <- tuk_df
dft <- tuk_summary.l[[3]]
filtered_df <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(2, 4)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe for only id2 pairs
tuk_summary.l[[paste("Interactions_",id1)]] <- filtered_df
# filter the interaction dataframe
filtered_df2 <- dft %>%
filter(sapply(strsplit(Subgroups, "[:-]"), "[", c(1, 3)) %>%
apply(2, function(x) all(x == x[1])))
# add the filtered dataframe to have matching id1 or id2 contrasts
tuk_summary.l[[paste("Interactions_",id2)]] <- filtered_df2
}
output_list <- list(ANOVA = aov_df,TukeyHSD = tuk_summary.l)
}
return(output_list)
}
}
#
# original get means function
get_means <- function(df, group_cols, value_col) {
df_means <- df %>%
group_by(across(all_of(group_cols))) %>%
mutate(expression = mean(value)) %>%
distinct(across(all_of(group_cols)), expression, .keep_all = TRUE) %>%
select(-value)
return(df_means)
}
input_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/FlowDataFiles/9MBO"
output_path <- "/Users/rhalenathomas/Documents/Data/FlowCytometry/PhenoID/Analysis/testingLibrary/"
# 1.a Read in FlowJo Files
# In Figure 3 downsample to 9000 where possible
# Here downsample to 1000 to speed up computation
flowset <- fsc_to_fs(input_path, downsample = 1000)
#install.packages("devtools")
library("devtools")
install.packages("roxygen2")
library("roxygen2")
setwd("~/GITHUB/CelltypeR/CelltypeR_library")
devtools::create("CelltypeR")
devtools::document()
devtools::document("/Users/rhalenathomas/GITHUB/CelltypeR/CelltypeR")
